#!/usr/bin/env python3

import itertools
import math
import subprocess
import argparse
import sys
import re
import os
from utils import style_unique, N_COLOR, get_bin, style



def get_prefix(texts):
    prefix = []
    for x in map(set, zip(*texts)):
        if len(x) == 1:
            prefix.append(x.pop())
        else:
            return "".join(prefix)
    return "".join(prefix)

def unprefix(texts):
    prefix = get_prefix(texts)
    np = len(prefix)
    return prefix, [x[np:] for x in texts if x[np:]]

def ordered_replace(text, original, replacement):
    for old, new in zip(original, replacement):
        text = text.replace(old, new)
    return text

def color_wrt_dir(lines, indices, current_dir, original, replacement):
    files, dirs = [], []
    for idx, line in zip(indices, lines):
        real_part = line[idx:].strip()
        if '.' not in real_part:
            dir_path = os.path.join(current_dir, real_part)
            abs_path = os.path.abspath(dir_path)
            if os.path.isdir(abs_path):
                dirs.append(ordered_replace(line, [real_part], [style(real_part, "DARKBLUE")]))
            else:
                files.append(ordered_replace(line, original, replacement))
        else:
            files.append(ordered_replace(line, original, replacement))
    return files + dirs

def get_prefixes(text, maxlen, minlen=4, min_match =3):
    prefixes = []
    text = [x for x in text if len(x)>min_match]
    while len(prefixes) < maxlen and text:
        ongoing = []
        for group in text:
            prefix, cut = unprefix(group)
            if len(prefix.strip()) >= minlen:
                prefixes.append(prefix)
            if len(cut) > min_match:
                ongoing.extend(cut)
        text = [list(v) for k, v in itertools.groupby(sorted(ongoing), key=lambda x: x[0])]
    return prefixes

def make_col(text, maxlen=100):
    textlen = max(len(x) for x in text)
    number_of_columns = int(maxlen / textlen)
    rows_in_columns = math.ceil(len(text)/number_of_columns)
    columns = []
    pattern = "{x:<{textlen}}"
    while len(text) > rows_in_columns:
        columns.append([pattern.format(x=x, textlen=textlen) for x in text[:rows_in_columns]])
        text = text[rows_in_columns:]
    columns.append([pattern.format(x=x, textlen=textlen) for x in text])
    zipped = list(itertools.zip_longest(*columns, fillvalue=''))
    return zipped



def lsc_dir(output, current_dir):
    if type(output) == str:
        output = [x for x in output.split("\n") if x]
    # check for boring permissions
    pattern = r"[-dclpsbD][-rwxsStTlL]{9}\+?(\s+\w+){6}\s+(\d+:\d+|\d{4})\s+"
    processed, idx,  original_text = [], [], []
    for line in output:
        match = re.match(pattern, line)
        if match:
            processed.append(line[match.end():])
            idx.append(match.end())
        else:
            processed.append(line)
            idx.append(0)


    for k, v in itertools.groupby(processed, key=lambda x: x[0]):
        original_text.append(list(v))

    to_color = get_prefixes(original_text, N_COLOR)
    styled = style_unique(*to_color)

    colored_text = [color_wrt_dir(x, idx, current_dir, to_color, styled) for x in make_col(output)]
    print("\n".join("    ".join(line) for line in colored_text))

def lsc(text):
    ls = get_bin("ls")
    ls_sub = [ls] + text
    encoding = sys.stdout.encoding
    p = subprocess.run(ls_sub, stdout=subprocess.PIPE, stderr=subprocess.PIPE, encoding=encoding)
    per_dir = [x for x in p.stdout.split(":\n") if x]
    split_dir = [[f for f in x.split("\n") if f] for x in per_dir]
    not_empty = [x for x in split_dir if x]

    try:
        current_dir = not_empty.pop(0)
        dir_name = ""
        while not_empty:
            dir_name = f"{current_dir.pop(-1)}:"
            try:
                lsc_dir(current_dir, dir_name[:-1])
            except:
                pass
            current_dir = not_empty.pop(0)
        lsc_dir(current_dir, dir_name[:-1])
    except:
        pass
    print(p.stderr)

lsc(sys.argv[1:])
